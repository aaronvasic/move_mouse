#!/usr/bin/env ruby
require 'yaml'
require 'tempfile'
require 'dbus'
require 'xdo'
require 'xdo/xwindow'
require 'xdo/mouse'
PROGNAME = File.basename($0).sub(/#{::File.extname($0)}$/,'')
INSTALLPATH = "#{ENV["HOME"]}/.local/bin/#{PROGNAME}"
testcmdname = "xscreentool"
testargs = %w[window move screen 1]

if ( ( $0 == '-' ) || ( ARGV[0] == 'test' ) )
    $0 = testcmdname
    $ARGV = testargs
else
    $ARGV = ARGV
end


module ::XScreenTool
    %w[ NoConfigFileException NoHomeException InvalidCommandTreeException InvalidScreenException InvalidArgumentException InvalidCommandException ].each do |word|
        const_set word,Class.new(Exception)
        define_singleton_method word,->(*args){const_get(word).new(*args)}
    end

    # Monitors:
    # hash where the keys are screen_identifier and values are screen_geometry
    Monitors=`xrandr --listmonitors | tail +2`.split(?\n).map{|line|line.split(' ')}.map{|line| { line[-1] => line[-2] } }.reduce({},:merge)

    module KDE
        module Shortcuts
            def self.register(screens)
                screens.each.with_index{|screen,idx|
                    p screen
                    p DBus::Service.new(
                        "org.kde.globalaccel",
                        DBus::SessionBus).methods

                }
            end
        end
        class ConfigWriter
            Command = 'kwriteconfig5 --file "%s" --group "%s" --key "%s" "%s"'
            attr_accessor :group
            def initialize(file)
                @file=file
            end
            def from_hash(hash)
                hash.each_pair{|group,keyval|
                    self.group=group.to_s
                    keyval.each_pair{|key,val|
                        write(key.to_s,val.to_s)
                    }
                }
            end
            private
            def write(key,value)
                system(Command % [@file,@group,key,value])
            end
        end
        class Config
            def initialize(file)
                @file=File::absolute_path(file)
            end
            def _write(group,key,value)
                c = "kwriteconfig5 --file \"#{@file}\" --group \"#{group}\" --key \"#{key}\" \"#{value}\""
                system c
            end
            def write(screens)
                name=self.class.to_s.split('::').first
                command_url=INSTALLPATH
                writer=ConfigWriter.new(@file)
                hash={
                    Main: {
                        AllowMerge: false,
                        Version: 2,
                        ImportId: name
                    },
                    Data: { DataCount: 1 },
                    Data_1: {
                        Comment: "#{name} Autogenerated Keybindings",
                        Enabled: true,
                        Name: name,
                        SystemGroup: '0',
                        DataCount: screens.count.to_s,
                        Type: 'ACTION_DATA_GROUP',
                    },
                    Data_1Conditions: {
                        Comment: '',
                        ConditionsCount: 0
                    }
                }
                screens.each.with_index{|screen,idx|
                    group_prefix="Data_1_#{idx+1}"
                    hash[group_prefix] = {
                        Comment:  screen.to_s,
                        Enabled:  true,
                        Name:  screen.identifier,
                        Type:  "SIMPLE_ACTION_DATA",
                    }
                    hash["#{group_prefix}Actions"]={
                        'ActionsCount' => 1
                    }
                    hash["#{group_prefix}Actions0"] = {
                        'CommandURL' => "#{command_url} screen #{screen.identifier}",
                        'Type' => "COMMAND_URL"
                    }
                    hash["#{group_prefix}Conditions"] = {
                        "Comment" => '',
                        "ConditionsCount" => '0'
                    }
                    hash["#{group_prefix}Triggers"] = {
                        "Comment" => 'Simple_action',
                        "TriggersCount" => '1'
                    }
                    hash["#{group_prefix}Triggers0"] = {
                        "Key" => screen.key_binding,
                        "Type" => "SHORTCUT",
                        "Uuid" => "{#{screen.key_uuid}}"
                    }
                }
                writer.from_hash hash
            end

        end
    end

    class Display < BasicObject
        config = ::ENV["XDG_CONFIG_HOME"]
        if config.nil?
            home = ::ENV["HOME"]
            if home.nil?
                raise ::XScreenTool::NoHomeException
            end
            config = "#{home}/.config"
        end
        ConfigFile = "#{config}/#{::PROGNAME}"
        raise ::XScreenTool::NoConfigFileException(ConfigFile) unless ::File.exists?(ConfigFile)
        Config = ::YAML::load_file(ConfigFile)
        Attr=[:identifier,:width,:height,:x,:y,:center,:key_binding,:key_uuid]
        attr_reader(*Attr)
        def initialize(screen_identifier)
            @screen=Monitors[screen_identifier]
            @identifier=screen_identifier
            geometry = @screen.split('/')
            @width=geometry.shift.to_i
            @height=geometry.shift.split('x').last.to_i
            offsets=geometry.shift.split('+')
            offsets.shift
            @x=offsets.shift.to_i
            @y=offsets.shift.to_i
            @center=[
                @width / 2 + @x,
                @height / 2 + @y]
            @key_binding = Config[screen_identifier]['key']
            @key_uuid = Config[screen_identifier]['keyuuid']
        end
        def inspect
            self.to_s
        end
        def to_s
            data = Attr.map{|var|
                "\t@#{var.to_s} => #{self.__send__ var}"
            }.join("\n")
            "Display:\n#{data}\n"
        end
    end
    Mouse=BasicObject.new
    class << Mouse
        def self.Speed=(x)
            @speed=x
        end
        self.Speed=50
        def xdotool(coords)
            x=coords[0].to_s
            y=coords[1].to_s
            c="xdotool mousemove #{x} #{y} #{@speed}"
            return c
        end
        def move(coords)
            set=false
            sync=false
            ::XDo::Mouse.move(*coords,@speed,set,sync)
        end
        def getCenterToWindow()
                    win=XDo::XWindow.new(XDo::XWindow.active_window)
                    win.position.zip( win.size.map{ |i|
                        i/2
                    }).map { |a,b|
                        a+b
                    }
        end
        def CenterToWindow()
            Mouse.move getCenterToWindow()
        end
        def xdotool_centerToWindow
            return(<<EOF
            geo=$(xdotool getactivewindow getwindowgeometry | tail +2)
            pos=$(cut -d' ' -f4 <<< $(head -1 <<< $geo))
            size=$(cut -d' ' -f4 <<< $(tail -1 <<< $geo))
            width=$(cut -d'x' -f1 <<< $size)
            height=$(cut -d'x' -f2 <<< $size)
            x=$(cut -d',' -f1 <<< $pos)
            y=$(cut -d',' -f2 <<< $pos)
            centerx=$(( width/2 + x ))
            centery=$(( height/2 + y ))
            xdotool mousemove $centerx $centery #{@speed}
EOF
)
        end
        def move_to_screen(screen)
            ::Kernel::raise(::XScreenTool::InvalidScreenException(screen)) if screen.nil?
            ::Kernel::raise(::XScreenTool::InvalidScreenException(screen)) unless Displays.each_index.member?(screen.to_i)
            self.move(Displays[screen.to_i].center)
        end
    end

    Displays = Monitors.keys.map{|id|Display.new(id)}

    class Window
        def MoveToScreen(*args)
                        idx_or_id=args[0]
                        idx_or_id=idx_or_id.to_i if idx_or_id.match(/^\d+$/)
                        screen=Displays[idx_or_id] if idx_or_id.is_a?(Integer)
                        screen=Displays.select{|display|display.identifier == idx_or_id }.first if idx_or_id.is_a?(String)
                        w = XDo::XWindow.new(XDo::XWindow.active_window)
                        w.move(screen.x,screen.y,true)
                        #script_template="workspace.activeClient.geometry=workspace.clientArea(workspace.PlacementArea,[%d,%d],0);"
                        #script= script_template % [ screen.x, screen.y ] #, *w.size ]
                        #KWin::Script.new(script).run
                        Mouse.CenterToWindow()
        end
    end

    CommandTree={
        screen: [ "screen_id\n(where screen_id is the screen's index number)",
                ->(*args){
                    raise ::XScreenTool::InvalidArgumentException(*args) unless args.first.match(/^\d+$/)
                    Mouse.move_to_screen(args.first)
                } ],
        install: {
            commands: [ "\n(no args)\n\nInstalls commands based on configuration to ~/.local/bin",
                ->(*args){
                    fname=INSTALLPATH
                    File.open(fname,"w+") do |io|
                        io.puts "#!/bin/bash"

                        io.puts "case $1 in"

                            io.puts '( "screen" )'
                                io.puts "case $2 in"
                                    Displays.each.with_index{|display,idx|
                                        io.puts "('#{idx}') #{Mouse.xdotool(display.center)} ;;"
                                        io.puts "('#{display.identifier}') #{Mouse.xdotool(display.center)} ;;"
                                    }
                                io.puts "esac"
                            io.puts ";;"

                            io.puts '( "mouse" )'
                                io.puts "case $2 in"
                                    io.puts ' ("centertowindow") '
                                        io.puts Mouse.xdotool_centerToWindow
                                    io.puts ";;"
                                io.puts "esac"
                            io.puts ";;"

                            io.puts '( "window" )'
                                io.puts 'echo asdf'
                            io.puts ";;"
                        io.puts "esac"
                    end
                    File.chmod(0700,fname)
                } ]
        },
        mouse: {
            centertowindow: [
                "\n(no args)",
                ->(){
                    Mouse.CenterToWindow
                } ]
        },
        window: {
            move: {
                screen: [
                    "screen_index|screen_identifier",
                    ->(*args){
                        Window.MoveToScreen(*args)
                    } ]
            },
            tile: {
                north: [
                    '',
                    ->(){
                    } ],
                south: [ '',
                    ->(){} ]
            }
        },
        kde: {
            config: [ "file\nwhere file is the name or path of the kconfig file to write",
                ->(*args){
                    raise ::XScreenTool::InvalidArgumentException if args[0].nil?
                    KDE::Config.new(args[0]).write(Displays)
                } ],
            shortcuts: {
                register: [ "\n(no args)\n(this function is broken)",
                ->(*args){
                    KDE::Shortcuts.register(Displays)
                } ]
            }
        },
        nil => [ '',
                ->(*args){ 'Arguments are required.' } ]
    }
    module KWin
        Bus = DBus::SessionBus.instance
        Service = Bus.service("org.kde.KWin")
        Scripting = Service.object("/Scripting")
        ScriptingPath = 'org.kde.kwin.Scripting'
        Interface=Scripting[ScriptingPath]
        class Script
            def script=(data)
                f = File.open(@fpath,'w')
                f.print data
                f.close
                @script=data
            end
            def script
                @script
            end
            def initialize(data=nil)
                @tmpfile=::Tempfile.new()
                @fpath=@tmpfile.path
                self.script=data
                @object=nil
                @script_id=nil
            end
            def load
                resp = Interface.loadScript(@fpath)
                @script_id = resp.first.to_s
                @object = Service.object("/#{@script_id}")
            end
            def run
                if @object.nil?
                    self.load
                end
                @object[ScriptingPath].run
            end
            def unload
                Interface.unloadScript(@script_id)
            end
        end
    end
    module CommandLine
        def interpret_commandtree(proc_or_hash=CommandTree,args=$ARGV.clone)
            case proc_or_hash.class.to_s
            when 'Array'
                if (args[0] == "--help" || args[0] == '-h')
                    puts "Command line spec:"
                    puts "#{$0} #{$ARGV[0..-2].join(' ')} #{proc_or_hash[0]}"
                    return
                end
                puts proc_or_hash[1].call(*args)
            when 'Hash'
                if args.size > 0
                    arg=args.shift.to_sym
                else
                    arg=nil
                end
                if (arg == :"help" || arg == :"--help" || arg == :'-h') && !(proc_or_hash.has_key?(arg))
                    puts "Available commands:"
                    proc_or_hash.keys.select{|k|k.is_a?(Symbol)}.each{|k|puts "\t#{k}"}
                    return
                end
                raise ::XScreenTool::InvalidArgumentException([proc_or_hash,args,$ARGV].to_s) unless proc_or_hash.has_key?(arg)
                interpret_commandtree(proc_or_hash[arg],args)
            else
                raise ::XScreenTool::InvalidCommandTreeException(proc_or_hash)
            end
        end
        class Interpreter
            include CommandLine
            def initialize(*args)
                interpret_commandtree(CommandTree,args)
            end
        end
    end
end


::XScreenTool::CommandLine::Interpreter.new(*$ARGV)
