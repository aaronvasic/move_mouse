#!/usr/bin/env ruby
require 'yaml'
require 'tempfile'
require 'dbus'
require 'xdo'
require 'xdo/xwindow'
require 'xdo/mouse'
testcmdname = "xscreentool"
testargs = %w[window move screen HDMI-0]

if ( ( $0 == '-' ) || ( ARGV[0] == 'test' ) )
    $0 = testcmdname
    $ARGV = testargs
else
    $ARGV = ARGV
end

PROGNAME = File.basename($0).sub(/#{::File.extname($0)}$/,'')
PROGDIR = File.dirname(File.absolute_path($0))
INSTALLPATH = "#{PROGDIR}/bin/#{PROGNAME}"


module ::XScreenTool
    config = ::ENV["XDG_CONFIG_HOME"]
    if config.nil?
        home = ::ENV["HOME"]
        if home.nil?
            raise ::XScreenTool::NoHomeException
        end
        config = "#{home}/.config"
    end
    ConfigFile = "#{config}/#{::PROGNAME}.yml"
    raise ::XScreenTool::NoConfigFileException(ConfigFile) unless ::File.exists?(ConfigFile)
    Config = ::YAML::load_file(ConfigFile)
    %w[ NoConfigFileException NoHomeException InvalidCommandTreeException InvalidScreenException InvalidArgumentException InvalidCommandException ].each do |word|
        const_set word,Class.new(Exception)
        define_singleton_method word,->(*args){const_get(word).new(*args)}
    end

    # Monitors:
    # hash where the keys are screen_identifier and values are screen_geometry
    Monitors=`xrandr --listmonitors | tail +2`.split(?\n).map{|line|line.split(' ')}.map{|line| { line[-1] => line[-2] } }.reduce({},:merge)

    module KDE
        module Shortcuts
            def self.register(screens)
                screens.each.with_index{|screen,idx|
                    p screen
                    p DBus::Service.new(
                        "org.kde.globalaccel",
                        DBus::SessionBus).methods

                }
            end
        end
        class ConfigWriter
            Command = 'kwriteconfig5 --file "%s" --group "%s" --key "%s" "%s"'
            attr_accessor :group
            def initialize(file)
                @file=file
            end
            def from_hash(hash)
                hash.each_pair{|group,keyval|
                    self.group=group.to_s
                    keyval.each_pair{|key,val|
                        write(key.to_s,val.to_s)
                    }
                }
            end
            private
            def write(key,value)
                system(Command % [@file,@group,key,value])
            end
        end
        class Config
            def initialize(file)
                @file=File::absolute_path(file)
            end
            def _write(group,key,value)
                c = "kwriteconfig5 --file \"#{@file}\" --group \"#{group}\" --key \"#{key}\" \"#{value}\""
                system c
            end
            def write(screens)
                name=self.class.to_s.split('::').first
                command_url=INSTALLPATH
                writer=ConfigWriter.new(@file)
                datas = []
                datas << {
                    nil => {
                        Comment: "#{name} autogenerated mouse moving keybindings",
                        Enabled: true,
                        Name: "#{name} Mouse",
                        SystemGroup: '0',
                        DataCount: screens.count.to_s,
                        Type: 'ACTION_DATA_GROUP',
                    },
                    Conditions: {
                        Comment: '',
                        ConditionsCount: 0
                    }
                }.merge(
                (screens.map.with_index{|screen,idx|
                    group_prefix="_#{idx+1}"
                    [
                        group_prefix => {
                            Comment:  screen.to_s,
                            Enabled:  true,
                            Name:  screen.identifier,
                            Type:  "SIMPLE_ACTION_DATA",
                        },
                        "#{group_prefix}Actions" => {
                            'ActionsCount' => 1
                        },
                        "#{group_prefix}Actions0" => {
                            'CommandURL' => "#{command_url} screen #{screen.identifier}",
                            'Type' => "COMMAND_URL"
                        },
                        "#{group_prefix}Conditions" => {
                            "Comment" => '',
                            "ConditionsCount" => '0'
                        },
                        "#{group_prefix}Triggers" => {
                            "Comment" => 'Simple_action',
                            "TriggersCount" => '1'
                        },
                        "#{group_prefix}Triggers0" => {
                            "Key" => screen.keys['mouse']['key'],
                            "Type" => "SHORTCUT",
                            "Uuid" => "{#{screen.keys['mouse']['uuid']}}"
                        } ]
                }).flatten.reduce({},:merge))
                datas << {
                    nil => {
                        Comment: "#{name} autogenerated window keybindings",
                        Enabled: true,
                        Name: "#{name} Window",
                        SystemGroup: '0',
                        DataCount: screens.count.to_s,
                        Type: 'ACTION_DATA_GROUP',
                    },
                    Conditions: {
                        Comment: '',
                        ConditionsCount: 0
                    }
                }.merge(
                (screens.map.with_index{|screen,idx|
                    group_prefix="_#{idx+1}"
                    [
                        group_prefix => {
                            Comment:  screen.to_s,
                            Enabled:  true,
                            Name:  screen.identifier,
                            Type:  "SIMPLE_ACTION_DATA",
                        },
                        "#{group_prefix}Actions" => {
                            'ActionsCount' => 1
                        },
                        "#{group_prefix}Actions0" => {
                            'CommandURL' => "#{command_url} window move screen #{screen.identifier}",
                            'Type' => "COMMAND_URL"
                        },
                        "#{group_prefix}Conditions" => {
                            "Comment" => '',
                            "ConditionsCount" => '0'
                        },
                        "#{group_prefix}Triggers" => {
                            "Comment" => 'Simple_action',
                            "TriggersCount" => '1'
                        },
                        "#{group_prefix}Triggers0" => {
                            "Key" => screen.keys['window']['key'],
                            "Type" => "SHORTCUT",
                            "Uuid" => "{#{screen.keys['window']['uuid']}}"
                        } ]
               }).flatten.reduce({},:merge))
                datas=datas.map.with_index{|data,idx|
                    data.map{ |k,v|
                        if k.nil?
                            suffix = ''
                        else
                            suffix = k.to_s
                        end
                        name = "Data_#{idx+1}#{suffix}"
                        [name,v]
                    }.to_h
                }
                datas << {
                    Main: {
                        AllowMerge: false,
                        Version: 2,
                        ImportId: name
                    },
                    Data: { DataCount: datas.count }
                }
                hash = datas.reduce({},:merge)
                writer.from_hash hash
            end

        end
    end

    class Display < BasicObject
        Attr=[:identifier,:width,:height,:x,:y,:center,:keys]
        attr_reader(*Attr)
        def initialize(screen_identifier)
            @screen=Monitors[screen_identifier]
            @identifier=screen_identifier
            geometry = @screen.split('/')
            @width=geometry.shift.to_i
            @height=geometry.shift.split('x').last.to_i
            offsets=geometry.shift.split('+')
            offsets.shift
            @x=offsets.shift.to_i
            @y=offsets.shift.to_i
            @center=[
                @width / 2 + @x,
                @height / 2 + @y]
            @keys = ::XScreenTool::Config[screen_identifier]["keys"]
        end
        def inspect
            self.to_s
        end
        def to_s
            data = Attr.map{|var|
                "\t@#{var.to_s} => #{self.__send__ var}"
            }.join("\n")
            "Display:\n#{data}\n"
        end
    end
    Mouse=BasicObject.new
    class << Mouse
        def speed=(x)
            @speed=x
        end
    end
    Mouse.speed=50
    class << Mouse
        def xdotool(coords)
            x=coords[0].to_s
            y=coords[1].to_s
            c="xdotool mousemove #{x} #{y} #{@speed}"
            return c
        end
        def move(coords)
            ::Kernel::puts @speed
            set=false
            sync=false
            ::XDo::Mouse.move(*coords,@speed,set,sync)
        end
        def getCenterToWindow()
                    win=::XDo::XWindow.new(::XDo::XWindow.active_window)
                    win.position.zip( win.size.map{ |i|
                        i/2
                    }).map { |a,b|
                        a+b
                    }
        end
        def CenterToWindow()
            Mouse.move getCenterToWindow()
        end
        def xdotool_centerToWindow
            return(<<EOF
            geo=$(xdotool getactivewindow getwindowgeometry | tail +2)
            pos=$(cut -d' ' -f4 <<< $(head -1 <<< $geo))
            size=$(cut -d' ' -f4 <<< $(tail -1 <<< $geo))
            width=$(cut -d'x' -f1 <<< $size)
            height=$(cut -d'x' -f2 <<< $size)
            x=$(cut -d',' -f1 <<< $pos)
            y=$(cut -d',' -f2 <<< $pos)
            centerx=$(( width/2 + x ))
            centery=$(( height/2 + y ))
            xdotool mousemove $centerx $centery
EOF
)
        end
        def move_to_screen(screen)
            ::Kernel::raise(::XScreenTool::InvalidScreenException(screen)) if screen.nil?
            ::Kernel::raise(::XScreenTool::InvalidScreenException(screen)) unless Displays.each_index.member?(screen.to_i)
            self.move(Displays[screen.to_i].center)
        end
    end

    Displays = Monitors.keys.map{|id|Display.new(id)}

    class Window
        def self.getMoveToScreen(*args)
                        idx_or_id=args[0]
                        idx_or_id=idx_or_id.to_i if idx_or_id.match(/^\d+$/)
                        screen=Displays[idx_or_id] if idx_or_id.is_a?(Integer)
                        screen=Displays.select{|display|display.identifier == idx_or_id }.first if idx_or_id.is_a?(String)
                        return [screen.x,screen.y]
        end
        def self.xdotool_moveToScreen(*args)
            coords=getMoveToScreen(*args)
            "xdotool getactivewindow windowmove --sync #{coords.map(&:to_s).join ' '} \n #{PROGNAME} mouse centertowindow"
        end
        def MoveToScreen(*args)
                        coords=getMoveToScreen(*args)
                        w = XDo::XWindow.new(XDo::XWindow.active_window)
                        w.move(*coords,true)
                        #script_template="workspace.activeClient.geometry=workspace.clientArea(workspace.PlacementArea,[%d,%d],0);"
                        #script= script_template % [ screen.x, screen.y ] #, *w.size ]
                        #KWin::Script.new(script).run
                        Mouse.CenterToWindow()
        end
    end

    module KWin
        Bus = DBus::SessionBus.instance
        Service = Bus.service("org.kde.KWin")
        Scripting = Service.object("/Scripting")
        ScriptingPath = 'org.kde.kwin.Scripting'
        Interface=Scripting[ScriptingPath]
        class Script
            def script=(data)
                f = File.open(@fpath,'w')
                f.print data
                f.close
                @script=data
            end
            def script
                @script
            end
            def initialize(data=nil)
                @tmpfile=::Tempfile.new()
                @fpath=@tmpfile.path
                self.script=data
                @object=nil
                @script_id=nil
            end
            def load
                resp = Interface.loadScript(@fpath)
                @script_id = resp.first.to_s
                @object = Service.object("/#{@script_id}")
            end
            def run
                if @object.nil?
                    self.load
                end
                @object[ScriptingPath].run
            end
            def unload
                Interface.unloadScript(@script_id)
            end
        end
    end
    module CommandLine
        COMMANDS_PATH = PROGDIR + "/commands"
        def load_commands()
            command_files = Dir.glob(COMMANDS_PATH + "/*.rb")
            command_files.each{|file|
                require_relative file.sub(/\.rb$/,'')
            }
        end
        def build_tree()
            tree={
                nil => [ '',
                        ->(*args){ 'Arguments are required.' } ]
            }
            load_commands unless CommandLine.const_defined?(:Command)
            Command::constants.each{|k| tree[k.downcase.to_sym]=Command.const_get k}
            return tree
        end
        def interpret_commandtree(proc_or_hash=nil,args=$ARGV.clone)
            proc_or_hash=build_tree if proc_or_hash.nil?
            case proc_or_hash.class.to_s
            when 'Array'
                if (args[0] == "--help" || args[0] == '-h')
                    puts "Command line spec:"
                    puts "#{$0} #{$ARGV[0..-2].join(' ')} #{proc_or_hash[0]}"
                    return
                end
                puts proc_or_hash[1].call(*args)
            when 'Hash'
                if args.size > 0
                    arg=args.shift.to_sym
                else
                    arg=nil
                end
                if (arg == :"help" || arg == :"--help" || arg == :'-h') && !(proc_or_hash.has_key?(arg))
                    puts "Available commands:"
                    proc_or_hash.keys.select{|k|k.is_a?(Symbol)}.each{|k|puts "\t#{k}"}
                    return
                end
                raise ::XScreenTool::InvalidArgumentException([proc_or_hash,args,$ARGV].to_s) unless proc_or_hash.has_key?(arg)
                interpret_commandtree(proc_or_hash[arg],args)
            else
                raise ::XScreenTool::InvalidCommandTreeException(proc_or_hash)
            end
        end
        class Interpreter
            include CommandLine
            def initialize(*args)
                interpret_commandtree(nil,args)
            end
        end
    end
end


::XScreenTool::CommandLine::Interpreter.new(*$ARGV)
