#!/usr/bin/env ruby
require 'yaml'
require 'dbus'

testcmdname = "xscreentool"
testargs = %w[window split north]

if $0 == '-'
    $0 = testcmdname
    $ARGV = testargs
end

module ::XScreenTool
    %w[ NoConfigFileException NoHomeException InvalidCommandTreeException InvalidScreenException InvalidArgumentException InvalidCommandException ].each do |word|
        const_set word,Class.new(Exception)
        define_singleton_method word,->(*args){const_get(word).new(*args)}
    end

    # Monitors:
    # hash where the keys are screen_identifier and values are screen_geometry
    Monitors=`xrandr --listmonitors | tail +2`.split(?\n).map{|line|line.split(' ')}.map{|line| { line[-1] => line[-2] } }.reduce({},:merge)

    module KDE
        module Shortcuts
            def self.register(screens)
                screens.each.with_index{|screen,idx|
                    p screen
                    p DBus::Service.new(
                        "org.kde.globalaccel",
                        DBus::SessionBus).methods

                }
            end
        end
        class Config
            def initialize(file)
                @file=file
            end
            def _write(group,key,value)
                c = "kwriteconfig5 --file \"#{@file}\" --group \"#{group}\" --key \"#{key}\" \"#{value}\""
                system c
            end
            def write(screens)
                _write('Main',"AllowMerge","false")
                _write('Main',"Version","2")
                _write('Data','DataCount','1')
                _write('Data_1','Comment',"#{self.class.to_s.split('::').first} Autogenerated Keybindings")
                _write('Data_1','Enabled','true')
                _write('Data_1','Name','MoveMouse')
                _write('Data_1','SystemGroup','0')
                _write('Data_1','DataCount',screens.count.to_s)
                _write('Data_1','Type','ACTION_DATA_GROUP')
                _write('Data_1Conditions','Comment','')
                _write('Data_1Conditions','ConditionsCount','0')
                screens.each.with_index{|screen,idx|
                    group_prefix="Data_1_#{idx+1}"
                    group=group_prefix
                    _write(group,"Comment", screen.to_s)
                    _write(group,"Enabled", 'true')
                    _write(group,"Name", screen.identifier)
                    _write(group,"Type", "SIMPLE_ACTION_DATA")
                    group="#{group_prefix}Actions"
                    _write(group,'ActionsCount',1)
                    group="#{group_prefix}Actions0"
                    _write(group,'CommandURL',"#{$0} screen #{idx}")
                    _write(group,'Type',"COMMAND_URL")
                    group="#{group_prefix}Conditions"
                    _write(group,"Comment",'')
                    _write(group,"ConditionsCount",'0')
                    group="#{group_prefix}Triggers"
                    _write(group,"Comment",'Simple_action')
                    _write(group,"TriggersCount",'1')
                    group="#{group_prefix}Triggers0"
                    _write(group,"Key",screen.key_binding)
                    _write(group,"Type","SHORTCUT")
                    _write(group,"Uuid","{#{screen.key_uuid}}")
                }
            end

        end
    end

    class Display < BasicObject
        config = ::ENV["XDG_CONFIG_HOME"]
        if config.nil?
            home = ::ENV["HOME"]
            if home.nil?
                raise ::XScreenTool::NoHomeException
            end
            config = "#{home}/.config"
        end
        ConfigFileName = ::File.basename($0).sub(/#{::File.extname($0)}$/,'')
        ConfigFile = "#{config}/#{ConfigFileName}"
        raise ::XScreenTool::NoConfigFileException(ConfigFile) unless ::File.exists?(ConfigFile)
        Config = ::YAML::load_file(ConfigFile)
        Attr=[:identifier,:width,:height,:x,:y,:center,:key_binding,:key_uuid]
        attr_reader(*Attr)
        def initialize(screen_identifier)
            @screen=Monitors[screen_identifier]
            @identifier=screen_identifier
            geometry = @screen.split('/')
            @width=geometry.shift.to_i
            @height=geometry.shift.split('x').last.to_i
            offsets=geometry.shift.split('+')
            offsets.shift
            @x=offsets.shift.to_i
            @y=offsets.shift.to_i
            @center=[
                @width / 2 + @x,
                @height / 2 + @y]
            @key_binding = Config[screen_identifier]['key']
            @key_uuid = Config[screen_identifier]['keyuuid']
        end
        def inspect
            self.to_s
        end
        def to_s
            data = Attr.map{|var|
                "\t@#{var.to_s} => #{self.__send__ var}"
            }.join("\n")
            "Display:\n#{data}\n"
        end
    end
    Mouse=BasicObject.new
    class << Mouse
        def xdotool(coords)
            x=coords[0].to_s
            y=coords[1].to_s
            c="xdotool mousemove #{x} #{y}"
            return c
        end
        def move(coords)
            ::Kernel.system xdotool(coords)
        end
        def move_to_screen(screen)
            ::Kernel::raise(::XScreenTool::InvalidScreenException(screen)) if screen.nil?
            ::Kernel::raise(::XScreenTool::InvalidScreenException(screen)) unless Displays.each_index.member?(screen.to_i)
            self.move(Displays[screen.to_i].center)
        end
    end

    Displays = Monitors.keys.map{|id|Display.new(id)}

    CommandTree={
        screen: [ "screen_id\n(where screen_id is the screen's index number)",
                ->(*args){
                    raise ::XScreenTool::InvalidArgumentException(*args) unless args.first.match(/\d+/)
                    Mouse.move_to_screen(args.first)
                } ],
        install: {
            commands: [ "\n(no args)\n\nInstalls commands based on configuration to ~/.local/bin",
                ->(*args){
                    fname="#{ENV["HOME"]}/.local/bin/#{`basename #{$0}`.chomp}"
                    File.open(fname,"w+") do |io|
                        io.puts "#!/bin/bash"
                        io.puts "case $2 in"
                        Displays.each.with_index{|display,idx|
                            io.puts "('#{idx}') #{Mouse.xdotool(display.center)} ;;"
                        }
                        io.puts "esac"
                    end
                    File.chmod(0700,fname)
                } ]
        },
        window: {
            split: {
                north: [ '',
                    ->(){'asdf'} ],
                south: [ '',
                    ->(){} ]
            }
        },
        kde: {
            config: [ "file\nwhere file is the name or path of the kconfig file to write",
                ->(*args){
                    raise ::XScreenTool::InvalidArgumentException if args[0].nil?
                    KDE::Config.new(args[0]).write(Displays)
                } ],
            shortcuts: {
                register: [ "\n(no args)\n(this function is broken)",
                ->(*args){
                    KDE::Shortcuts.register(Displays)
                } ]
            }
        },
        nil => [ '',
                ->(*args){ 'Arguments are required.' } ]
    }
    module CommandLine
        def interpret_commandtree(proc_or_hash=CommandTree,args=ARGV.clone)
            case proc_or_hash.class.to_s
            when 'Array'
                if (args[0] == "--help" || args[0] == '-h')
                    puts "Command line spec:"
                    puts "#{$0} #{ARGV[0..-2].join(' ')} #{proc_or_hash[0]}"
                    return
                end
                puts proc_or_hash[1].call(*args)
            when 'Hash'
                if args.size > 0
                    arg=args.shift.to_sym
                else
                    arg=nil
                end
                if (arg == :"help" || arg == :"--help" || arg == :'-h') && !(proc_or_hash.has_key?(arg))
                    puts "Available commands:"
                    proc_or_hash.keys.select{|k|k.is_a?(Symbol)}.each{|k|puts "\t#{k}"}
                    return
                end
                raise ::XScreenTool::InvalidArgumentException([proc_or_hash,args,ARGV].to_s) unless proc_or_hash.has_key?(arg)
                interpret_commandtree(proc_or_hash[arg],args)
            else
                raise ::XScreenTool::InvalidCommandTreeException(proc_or_hash)
            end
        end
        class Interpreter
            include CommandLine
            def initialize(*args)
                interpret_commandtree(CommandTree,args)
            end
        end
    end
end

if File::extname($0) == '.rb'
    ::XScreenTool::CommandLine::Interpreter.new(*ARGV)
end
